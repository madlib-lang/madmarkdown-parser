import type { Either } from "Either"
import type { Maybe } from "Maybe"
import type { Parser } from "Parse"

import { apL } from "Applicative"
import { mapLeft } from "Either"
import {} from "Float"
import { always, equals, identity } from "Function"
import { mapL } from "Functor"
import IO from "IO"
import { dropWhile, mapMaybe } from "List"
import { Just, Nothing, fromMaybe } from "Maybe"
import P from "Parse"
import String from "String"

import { between } from "@/Combinators"
import { linkCharacter } from "@/Link"
import { SPACE, blank, singleReturnTerminal } from "@/Shared"



// https://help.obsidian.md/Editing+and+formatting/Properties
// MadMarkdownParser aims to support the YAML that is supported by Obsidian,
// _not_ the entire YAML spec
export type YamlValue
  = YamlString(String)
  | YamlFloat(Float)
  | YamlInteger(Integer)
  | YamlBoolean(Boolean)
  | YamlLink(String, String)
  | YamlInternalLink(String, String)
  | YamlDate(String)
  | YamlList(List YamlValue)

// key / value
export type YamlPair = YamlPair(String, YamlValue)

export alias YamlData = List YamlPair

link :: P.Parser YamlValue
export link = pipe(
  map(YamlLink),
  ap(
    $,
    between(
      P.char('('),
      pipe(
        P.many,
        map(String.fromList),
      )(linkCharacter),
      P.char(')'),
    ),
  ),
)(
  between(
    P.char('['),
    pipe(
      P.many,
      map(String.fromList),
    )(P.notOneOf([']', '\n'])),
    P.char(']'),
  ),
)

shortInternalLink :: Parser YamlValue
export shortInternalLink = do {
  _ <- P.string(`"[[`)
  ref <- pipe(
    P.manyTill(P.letter),
    map(String.fromList),
  )(P.string(`]]"`))
  _ <- P.string(`]]"`)
  return pipe(
    YamlInternalLink(ref),
    of,
  )(ref)
}

internalLinkWithDisplay :: Parser YamlValue
export internalLinkWithDisplay = do {
  _ <- P.string(`"[[`)
  url <- pipe(
    P.many,
    map(String.fromList),
  )(linkCharacter)
  _ <- P.char('|')
  ref <- pipe(
    P.manyTill(P.letter),
    map(String.fromList),
  )(P.string(`]]"`))
  _ <- P.string(`]]"`)
  return pipe(
    YamlInternalLink(ref),
    of,
  )(url)
}

internalLink :: P.Parser YamlValue
export internalLink = P.choice([internalLinkWithDisplay, shortInternalLink])

boolTrue :: P.Parser YamlValue
export boolTrue = do {
  matched <- P.string("true")
  return pipe(
    YamlBoolean,
    of,
  )(true)
}

boolFalse :: P.Parser YamlValue
export boolFalse = do {
  matched <- P.string("false")
  return pipe(
    YamlBoolean,
    of,
  )(false)
}

export boolean = P.choice([boolTrue, boolFalse])

numeric = map(
  pipe(
    String.fromList,
    scan,
    fromMaybe(0),
  ),
)

integer :: P.Parser YamlValue
export integer = do {
  num <- numeric(P.manyTill(P.digit, P.lookAhead(P.char('\n'))))
  return pipe(
    YamlInteger,
    of,
  )(num)
}
float :: P.Parser YamlValue
export float = do {
  num <- numeric(P.manyTill(P.digit, P.lookAhead(P.char('.'))))
  _ <- P.char('.')
  floating <- numeric(P.manyTill(P.digit, P.lookAhead(P.char('\n'))))
  return pipe(
    scan,
    fromMaybe(0),
    YamlFloat,
    of,
  )(`${show(num)}.${show(floating)}`)
}

export text = pipe(
  P.someTill($, P.lookAhead(P.char('\n'))),
  map(
    pipe(
      String.fromList,
      String.trim,
      YamlString,
    ),
  ),
)(P.notChar('\n'))

export yamlSingleContent = P.choice([link, internalLink, integer, float, boolean, text])

export yamlContent = pipe(
  P.choice,
  P.many,
)([link, internalLink, integer, float, boolean, text])

export list = pipe(
  chain(always(apL(yamlSingleContent, singleReturnTerminal))),
)(blank(apL(P.many(SPACE), apL(P.char('-'), P.some(SPACE)))))

yamlPair :: P.Parser YamlPair
export yamlPair = do {
  key <- map(String.fromList, P.manyTill(P.choice([P.letter, P.digit]), P.lookAhead(P.char(':'))))
  value <- between(P.char(':'), yamlSingleContent, P.char('\n'))
  return pipe(
    YamlPair(key, $),
    of,
  )(value)
}
